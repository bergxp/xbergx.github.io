/ *
 Direitos autorais (C) Federico Zivolo 2019
 Distribuído sob a licença MIT (os termos da licença estão em http://opensource.org/licenses/MIT).
 * / (function (e, t) {'objeto' == tipo de exportações && 'indefinido'! = tipo de módulo? module.exports = t (): 'função' == tipo de definição && define.amd? define (t): e. Popper = t ()}) (this, function () {'use strict'; function e (e) {return e && '[objeto Function]' === {}. ToString.call (e)} function t (e , t) {if (1! == e.nodeType) retorna []; var o = e.ownerDocument.defaultView, n = o.getComputedStyle (e, null); retorna t? n [t]: n} função o (e) {return'HTML '=== e.nodeName? e: e.parentNode || e.host} função n (e) {if (! e) retorna document.body; switch (e.nodeName) {case 'HTML': case'BODY ': retornar e.ownerDocument.body; case' # document ': retornar e.body;} var i = t (e), r = i.overflow, p = i.overflowX, s = i.overflowY; return /(auto|scroll|overlay)/.test(r+s+p)?e:n(o(e))}função i (e) {return e && e.referenceNode? e.referenceNode:e} função r (e) {return 11 === e? re: 10 === e? pe: re || pe} função p (e) {if (! e) retorna document.documentElement; for (var o = r (10)? document.body: null, n = e.offsetParent || null; n === o && e.nextElementSibling;) n = (e = e.nextElementSibling) .offsetParent; vari = n &&n.nodeName; return i && 'BODY'! == i && 'HTML'! == i? -1! == ['TH', 'TD', 'TABLE']. indexOf (n.nodeName) && 'static' === t ( n, 'position')? p (n): n: e? e.ownerDocument.documentElement: document.documentElement} função s (e) {var t = e.nodeName; return'BODY '! == t && (' HTML '=== t || p (e.firstElementChild) === e)} função d (e) {return null === e.parentNode? e: d (e.parentNode)} função a (e, t) {if (! e ||! e.nodeType ||! t ||! t.nodeType) retorna document.documentElement; var o = e.compareDocumentPosition (t) & Node.DOCUMENT_POSITION_FOLLOWING, n = o? e: t, i = o? t:e, r = document.createRange (); r.setStart (n, 0), r.setEnd (i, 0); var l = r.commonAncestorContainer; if (e! == l && t! == l || n. (i)) return s (l)? l: p (l); var f = d (e); return f.host?a(f.host,t):a(e,d(t).host )} função l (e) {var t = 1 <argumentos.length && void 0! == argumentos [1]? argumentos [1]: 'top', o = 'top' === t? 'scrollTop': 'scrollLeft ', n = e.nodeName; if (' CORPO '=== n ||' HTML '=== n) {var i = e.ownerDocument.documentElement, r = e.ownerDocument.scrollingElement || i; return r [o]} retorna e [o]} função f (e, t) {var o = 2 <argumentos.length && void 0! == argumentos [2] && argumentos [2], n = l (t, 'top'), i = l (t, 'esquerda'), r = o? -1: 1; return e.top + = n * r, e.bottom + = n * r, e.left + = i * r, e right + = i * r, e} função m (e, t) {var o = 'x' === t? 'Esquerda': 'Superior', n = 'Esquerda' == o? 'Direita': 'Inferior';return parseFloat (e ['borda' + o + 'Largura'], 10) + parseFloat (e ['borda' + n + 'Largura'], 10)} function h (e, t, o, n) {return ee ( t ['deslocamento' + e], t ['rolagem' + e], o ['cliente' + e], o ['deslocamento' + e], o ['rolagem' + e], r (10)? parseInt (o ['deslocamento' + e]) + parseInt (n ['margem' + ('Altura' === e? 'Superior': 'Esquerda')]) + parseInt (n ['margem' + (' Height '=== e?' Bottom ':' Right ')]): 0)} function c (e) {var t = e.body, o = e.documentElement, n = r (10) && getComputedStyle (o) ; return {height: h ('Height', t, o, n), width: h ('Width', t, o, n)}} função g (e) {return le ({}, e, {right : e.left + e.width, bottom: e.top + e.height})} função u (e) {var o = {}; tente {if (r (10)) {o = e.getBoundingClientRect () ; var n = l (e, 'top'), i = l (e, 'left'); o.top + = n, o.left + = i, o.bottom + = n, o.right + = i} mais o = e.getBoundingClientRect ()} catch (t) {} var p = {left: o.left, top: o.top, largura: o.right-o.left, altura: o.bottom-o.top}, s = ' HTML '=== e.nodeName? C (e.ownerDocument): {}, d = s.width || e.clientWidth || p.width, a = s.height || e.clientHeight || p.height , f = e.offsetWidth-d, h = e.offsetHeight-a; if (f || h) {var u = t (e); f- = m (u, 'x'), h- = m ( u, 'y'), largura da p = f, altura da p = h} retorna g (p)} função b (e, o) {var i = 2 <argumentos.length && void 0! == argumentos [2 ] && argumentos [2], p = r (10), s = 'HTML' === o.nodeName, d = u (e), a = u (o), l = n (e), m = t ( o), h = parseFloat (m.borderTopWidth, 10), c = parseFloat (m.borderLeftWidth, 10); i && s && (a.top = ee (a.top, 0), a.left = ee (a.left, 0)); var b = g ({top: d.top-a.top-h, esquerda: d.left-a.left-c, largura: d.width, height: d.height}); if ( b.marginTop = 0, b.marginLeft = 0,! p && s) {var w = parseFloat (m.marginTop, 10), y = parseFloat (m.marginLeft, 10); b.top- = hw, b.bottom- = hw, b.left- = cy, b.right- = cy, b.marginTop = w, b.marginLeft = y} return (p &&! i? o.contains (l): o === l && ' BODY '! == l.nodeName) && (b = f (b, o)), b} função w (e) {var t = 1 <argumentos.length && void 0! == argumentos [1] && argumentos [1], o = e.ownerDocument.documentElement, n = b (e, o), i = ee (o.ClientWidth, window.innerWidth || 0), r = ee (o.clientHeight, window.innerHeight || 0), p = t? 0: l (o), s = t? 0: l (o, 'left'), d = {top: pn.top + n.marginTop, esquerda: sn.left + n.marginLeft, largura: i, height: r}; return g (d)} função y (e) {var n = e.nodeName; if ('BODY' === n || 'HTML' === n) return! 1; if ('fixo' === t (e, 'posição')) return! 0; var i = o (e); return !! i && y (i)} função E (e) {if (! e ||! e .parentElement || r ()) return document.documentElement; for (var o = e.parentElement; o && 'none' === t (o, 'transform');) o = o.parentElement;return o || document.documentElement} função v (e, t, r, p) {var s = 4 <argumentos.length && void 0! == argumentos [4] && argumentos [4], d = {topo: 0, à esquerda: 0}, l = s? E (e): a (e, i (t)); if ('viewport' === p) d = w (l, s); else {var f; 'scrollParent' = == p? (f = n (o (t)), 'CORPO' === f.nodeName && (f = e.ownerDocument.documentElement)): 'janela' === p? f = e.ownerDocument.documentElement () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () ()) () () () () () () () () () () () () () () () () ()) Para obter mais informações, consulte o site do fabricante, que pode ser encontrado no site da fabricante, no site do fabricante. } else d = m} r = r || 0; var v = 'número' == tipo de r; retorno d.left + = v? r: r.left || 0, d.top + = v? r: r. top || 0, d.right- = v? r: r.right || 0, d.bottom- = v? r: r.bottom || 0, d} função x (e) {var t = e. width, o = e.height; return t * o} função O (e, t, o, n, i) {var r = 5 <argumentos.length && void 0!== argumentos [5]? argumentos [5]: 0; if (-1 === e.indexOf ('auto')) retorna e; var p = v (o, n, r, i), s = { top: {width: p.width, height: t.top-p.top}, à direita: {width: p.right-t.right, height: p.height}, bottom: {width: p.width, height : p.bottom-t.bottom}, esquerda: {width: t.left-p.left, altura: p.height}}, d = Object.keys (s) .map (function (e) {return le ( {chave: e}, s [e], {área: x (s [e])})}). sort (função (e, t) {retornar t.area-e.area}), a = d. filtro (função (e) {var t = largura e, n = altura e; retorno t> = largura do cliente & & n> = altura do cliente}), l = 0 <comprimento.a [0] .key: d [0] .key, f = e.split ('-') [1]; retorna l + (f? '-' + f: '')} função L (e, t, o) {var n = 3 <argumentos.length && void 0! == argumentos [3]? argumentos [3]: nulo, r = n? E (t): a (t, i (o)); função de retorno b (o, r, n)} S (e) {var t = e.ownerDocument.defaultView, o = t.getComputedStyle (e), n = parseFloat (o.marginTop || 0) + parseFloat (o.marginBottom || 0),i = parseFloat (o.marginLeft || 0) + parseFloat (o.marginRight || 0), r = {width: e.offsetWidth + i, altura: e.offsetHeight + n}; retorno r} função T (e) {var t = {left: 'right', right: 'left', bottom: 'top', top: 'bottom'}; return e.replace (/ left | right | bottom | top / g, função (e) {return t [e]})} função C (e, t, o) {o = o.split ('-') [0]; var n = S (e), i = {width: n.width, height: n.height}, r = -1! == ['direita', 'esquerda']. indexOf (o), p = r? 'top': 'esquerda', s = r? 'esquerda': ' top ', d = r?' height ':' width ', a = r?' width ':' height '; retorno i [p] = t [p] + t [d] / 2-n [d] / 2, i [s] = o === s? T [s] -n [a]: t [T (s)], i} função D (e, t) {retornar Array.prototype.find? E. find (t): e.filter (t) [0]} função N (e, t, o) {if (Array.prototype.findIndex) retorna e.findIndex (função (e) {retorna e [t] == = o}); var n = D (e, função (e) {return e [t] === o}); return e.indexOf (n)} função P (t, o, n) {var i = void 0 === n? t: t.slice (0, N (t, 'nome', n)); return i.forEach ( function (t) {t ['function'] && console.warn ('' modifier.function` está obsoleta, use `modifier.fn`! '); var n = t [' function '] || t.fn; t .enabled && e (n) && (o.offsets.popper = g (o.offsets.popper), o.offsets.reference = g (o.offsets.reference), o = n (o, t))}), o } função k () {if (! this.state.isDestroyed) {var e = {instance: this, styles: {}, arrowStyles: {}, atributos: {}, invertido:! 1, offsets: {}}; e.offsets.reference = L (este.estado, esse.popper, essa.referência, essa.opções.posiçãoFixada), e.placement = O (essa.opções.placement, e.offsets.reference, esse.popper, esse .reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding), e.originalPlacement = e.placement, e.positionFixed = this.options.positionFixed, e.offsets.popper = C ( isto.popper, e.offsets.reference, e.placement), e.offsets.popper.position = this.options.positionFixed? 'Fixed': 'absolute', e = P (this.modifiers, e), this.state. isCreated? this.options.onUpdate (e) :( this.state.isCreated =! 0, this.options.onCreate (e))}} função W (e, t) {retornar e.some (function (e) { var o = e.name, n = e.enabled; return n && o === t})} função B (e) {for (var t = [! 1, 'ms', 'Webkit', 'Moz', ' O '], o = e.charAt (0) .toUpperCase () + e.slice (1), n ​​= 0; n <comprimento de t; n ++) {vari = t [n], r = i?' '+ i + o: e; if (' indefinido '! = tipo de documento.body.estilo [r]) retornar r} retornar nulo} função H () {retornar this.state.isDestroyed =! 0, W (this. modificadores, 'applyStyle') && (this.popper.removeAttribute ('x-placement'), this.popper.style.position = '', this.popper.style.top = '', this.popper.style.left = '', este.popper.style.right = '', this.popper.style.bottom = '', this.popper.style.willChange = '', this.popper.style [B ('transform')] = ''), this.disableEventListeners (), this.options.removeOnDestroy && this.popper.parentNode.removeChild (this.popper), esta} função A (e) {var t = e.ownerDocument; retorna t? t.defaultView: window} função M (e, t , o, i) {var r = 'BODY' === e.nodeName, p = r? e.ownerDocument.defaultView: e; p.addEventListener (t, o, {passive:! 0}), r || Função M (n (p.parentNode), t, o, i), i.push (p)} F (e, t, o, i) {o.updateBound = i, A (e) .addEventListener ('redimensionar ', o.updateBound, {passivo:! 0}); var r = n (e); retorna M (r,' rolagem ', o.updateBound, o.scrollParents), o.scrollElement = r, o.eventsEnabled = ! 0, o} função I () {this.state.eventsEnabled || (this.state = F (this.reference, this.options, this.state, this.state, this.scheduleUpdate))} function R (e, t) { retornar A (e).removeEventListener ('redimensionar', t.updateBound), t.scrollParents.forEach (function (e) {e.removeEventListener ('rolagem', t.updateBound)}), t.updateBound = null, t.scrollParents = [], t.scrollElement = null, t.eventsEnabled =! 1, t} função U () {this.state.eventsEnabled && (cancelAnimationFrame (this.scheduleUpdate)) this.state = R (this.reference, this.state))} function Y (e) {return ''! == e &&! IsNaN (parseFloat (e)) && isFinite (e)} função V (e, t) {Object.keys (t) .forEach (function (o) {var n = ''; -1! == ['largura', 'altura', 'superior', 'direita', 'inferior', 'esquerda']. IndexOf (o) && Y (t [o]) && (n = ' px '), e.style [o] = t [o] + n})} função j (e, t) {Object.keys (t) .forEach (function (o) {var n = t [o]; ! 1 === n? E.removeAttribute (o): e.setAttribute (o, t [o])})} função q (e, t) {var o = e.offsets, n = o.popper, i = o.reference,r = $, p = função (e) {retorno e}, s = r (largura i), d = r (largura n), a = -1! == ['esquerda', 'direita']. indexOf (e.placement), l = -1! == e.placement.indexOf ('-'), f = t? a || l || s% 2 == d% 2? r: Z: p, m = t? r: p; return {left: f (1 == s% 2 && 1 == d% 2 &&! l && t? n.left-1: n.left), em cima: m (n.top), em baixo: m (n.bottom), direita: f (n.right)}} função K (e, t, o) {var n = D (e, função (e) {var o = e.name; return o == = t}), i = !! n && e.some (function (e) {return e.name === o && e.enabled && e.order <n.order}); if (! i) {var r = '' '+ t + '' '; console.warn (' '+ o +' '' + 'modificador é exigido pelo modificador' + r + 'para funcionar, certifique-se de incluí-lo antes de' + r + '!')} return i} função z (e) {return'end '=== e?' start ':' start '=== e?' end ': e} função G (e) {var t = 1 <argument.length && void 0! = = argumentos [1] && argumentos [1], o = he.indexOf (e), n = he.slice (o + 1) .concat (he.slice (0, o)); return t? n.reverse (): n} function _ (e, t, o, n) {var i = e.match (/ ((:: \ - | \ +)? \ d * \.? \ d *) (. *) /), r = + i [1], p = i [2]; if (! R) retorna e; if (0 === p.indexOf ('%')) {var s; switch (p) {case '% p': s = o; break; case '%': case '% r': padrão: s = n;} var d = g (s); retorno d [t] / 100 * r} if ('vh' === p || 'vw' === p) {var a; retornar a = 'vh' === p? ee (document.documentElement.clientHeight, window.innerHeight || 0): ee (document.documentElement.clientWidth, window .innerWidth || 0), a / 100 * r} retorna r} função X (e, t, o, n) {vari = [0,0], r = -1! == ['right', ' left ']. indexOf (n), p = e.split (/ (\ + | \ -) ​​/). map (function (e) {return e.trim ()}), s = p.indexOf (D ( p, função (e) {return-1! == e.search (/, | \ s /)})); p [s] && - 1 === p [s] .indexOf (',') && console .advertir('Os deslocamentos separados por espaços em branco são preteridos, use vírgula (,). '); Var d = / \ s *, \ s * | \ s + /, a = -1 === s? [P] : [p.slice (0, s) .concat ([p [s] .split (d) [0]]), [p [s] .split (d) [1]]. concat (p.slice ( s + 1))]; retorna a = a.map (função (e, n) {var i = (1 === n?! r: r)? 'height': 'width', p =! 1; return e.reduce (function (e, t) {return '' === e [e.length-1] && - 1! == ['+', '-']. indexOf (t)? (e [ e.length-1] = t, p =! 0, e): p? (e [e.length-1] + = t, p =! 1, e): e.concat (t)}, [] ) .map (função (e) {retornar _ (e, i, t, o)})}), a.forEach (função (e, t) {e.forEach (função (o, n) {Y (o ) && (i [t] + = o * ('-' === e [n-1]? - 1: 1))})}), i} função J (e, t) {var o, n = t.offset, i = e.placement, r = e.offsets, p = r.popper, s = r.reference, d = i.split ('-') [0]; return o = Y (+ n )? [+ n, 0]: X (n, p, s, d), 'esquerda' === d? (p.top + = o [0], p.left- = o [1]): ' right '=== d? (p.top + = o [0], p.left + = o [1]):'top '=== d? (p.left + = o [0], p.top- = o [1]):' bottom '=== d && (p.left + = o [0], p.top + = o [1]), e.popper = p, e} var Q = Math.min, Z = Math.floor, $ = Math.round, ee = Math.max, te = 'indefinido'! = Tipo de janela && 'indefinido' ! = typeof document && 'undefined'! = typeof navigator, oe = function () {for (var e = ['Edge', 'Trident', 'Firefox'], t = 0; t <e.length; t + = 1 ) if (te && 0 <= navigator.userAgent.indexOf (e [t])) return 1; return 0} (), ne = te && window.Promise, ie = ne? function (e) {var t =! 1; return function () {t || (t =! 0, window.Promise.resolve (). then (function () {t =! 1, e ()}))}}: function (e) {var t =! 1 ; return function () {t || (t =! 0, setTimeout (function () {t =! 1, e ()}, oe))}}, re = te && !! (window.MSInputMethodContext && document.documentMode), pe = te && / MSIE 10 / .test (navigator.userAgent), se = função (e, t) {if (!(e instanceof t)) lança novo TypeError ('Não é possível chamar uma classe como função')}, de = function () {function e (e, t) {for (var o, n = 0; n <t.length ; n ++) o = t [n], o.enumerable = o.enumerable ||! 1, o.configurable =! 0, 'valor' em o && (o.writable =! 0), Object.defineProperty (e, o .key, o)} função de retorno (t, o, n) {retorno o && e (t.prototype, o), n && e (t, n), t}} (), ae = function (e, t, o) { return t em e? Object.defineProperty (e, t, {valor: o, enumerável:! 0, configurável:! 0, gravável:! 0}): e [t] = o, e}, le = Object.assign || função (e) {for (var t, o = 1; o <argumentos.length; o ++) for (var n em t = argumentos [o], t) Object.prototype.hasOwnProperty.call (t, n) && (e [n] = t [n]); return e}, fe = te && / Firefox / i.test (navigator.userAgent), me = ['início automático', 'automático', 'final automático' , "início inicial", "início", "início final", "início inicial", "direito",'final direito', 'final inferior', 'inferior', 'início inferior', 'final esquerdo', 'esquerdo', 'início esquerdo'], he = me.slice (3), ce = {FLIP: 'flip', CLOCKWISE: 'sentido horário', COUNTERCLOCKWISE: 'sentido anti-horário'}, ge = function () {função t (o, n) {var i = this, r = 2 <argumentos.length && void 0! == argumentos [2]? argumentos [2]: {}; se (this, t), this.scheduleUpdate = function () {return requestAnimationFrame (i.update)}, this.update = ie (this.update.bind (this )), this.options = le ({}, t.Defaults, r), this.state = {isDestroyed:! 1, isCreated:! 1, scrollParents: []}, this.reference = o && o.jquery? o [ 0]: o, this.popper = n && n.jquery? N [0]: n, this.options.modifiers = {}, Object.keys (le ({}, t.Defaults.modifiers, r.modifiers)). forEach (função (e) {i.options.modifiers [e] = le ({}, t.Defaults.modifiers [e] || {}, r.modifiers? r.modifiers [e]: {})}) ,isto.modificadores = Object.keys (this.options.modifiers) .map (função (e) {retorna le ({nome: e}, i.options.modifiers [e])}). sort (função (e, t) { retornar e.order-t.order}), this.modifiers.forEach (function (t) {t.enabled && e (t.onLoad) && t.onLoad (i.reference, i.popper, i.options, t, i. estado)}), this.update (); var p = this.options.eventsEnabled; p && this.enableEventListeners (), this.state.eventsEnabled = p} return de (t, [{key: 'update', value: function () {return k.call (this)}}, {key: 'destroy', value: function () {return H.call (this)}}, {key: 'enableEventListeners', value: function () {return I.call (this)}}, {key: 'disableEventListeners', value: function () {return U.call (this)}}]), t} (); return ge.Utils = ('undefined' == typeof window? global: window) .PopperUtils, ge.placements = eu, ge.Defaults = {posicionamento: 'inferior', positionFixed:! 1, eventsEnabled:! 0,removeOnDestroy:! 1, onCreate: function () {}, onUpdate: function () {}, modificadores: {shift: {order: 100, enabled:! 0, fn: function (e) {var t = e.placement, o = t.split ('-') [0], n = t.split ('-') [1]; se (n) {var i = compensações e, r = referência i, p = i. popper, s = -1! == ['bottom', 'top']. indexOf (o), d = s? 'left': 'top', a = s? 'width': 'height', l = {start: ae ({}, d, r [d]), end: ae ({}, d, r [d] + r [a] -p [a])}; e.offsets.popper = le ( {}, p, l [n])} retorne e}}, deslocamento: {order: 200, ativado:! 0, fn: J, offset: 0}, preventOverflow: {order: 300, ativado:! 0, fn : função (e, t) {var o = t.boundariesElement || p (e.instance.popper); e.instance.reference === o && (o = p (o)); var n = B ('transform '), i = e.instance.popper.style, r = i.top, s = i.left, d = i [n]; i.top =' ', i.left =' ', i [n] = ''; var a = v (e.instance.popper, e.instance.reference, t.padding, o, e.positionFixed); i.top = r, i.left = s, i [n] = d, t. limites = a; var l = prioridade t, f = e.offsets.popper, m = {primary: function (e) {var o = f [e]; return f [e] <a [e] &&! t.escapeWithReference && (o = ee (f [e], a [e])), ae ({}, e, o)}, secundário: function (e) { var o = 'right' === e? 'left': 'top', n = f [o]; return f [e]> a [e] &&! t.escapeWithReference && (n = Q (f [o] , a [e] - ('right' === e? f.width: f.height))), ae ({}, o, n)}}; retorne l.forEach (function (e) {var t = -1 === ['esquerda', 'superior']. IndexOf (e)? 'Secundário': 'primário'; f = le ({}, f, m [t] (e))}), e .offsets.popper = f, e}, prioridade: ['left', 'right', 'top', 'bottom'], preenchimento: 5, boundariesElement: 'scrollParent'}, keepTogether: {order: 400, enabled: ! 0, fn: function (e) {var t = e.offsets, o = t.popper, n = t.reference, i = e.placement.split ('-') [0], r = Z, p = -1! == ['top', 'bottom ']. indexOf (i), s = p?' right ':' bottom ', d = p?' left ':' top ', a = p?' width ':' height '; return o [s] <r (n [d]) && (e.offsets.popper [d] = r (n [d]) - o [a]), o [d]> r (n [s]) && (e.offsets .popper [d] = r (n [s])), e}}, seta: {order: 500, enabled:! 0, fn: function (e, o) {var n; if (! K (e. instance.modifiers, 'arrow', 'keepTogether')) return e; var i = o.element; if ('string' == tipo de i) {if (i = e.instance.popper.querySelector (i) ,! i) return e;} else if (! e.instance.popper.contains (i)) return console.warn ('WARNING: `arrow.element` deve ser filho de seu elemento popper!'), e; var r = e.placement.split ('-') [0], p = e.offsets, s = p.popper, d = p.reference, a = -1! == ['left', 'right']. (r), l = a? 'height': 'width', f = a? 'Top': 'Left', m = f.toLowerCase (), h = a? 'left': 'top ', c = a?' bottom ':' right ', u = S (i) [l]; d [c] -u <s [m] && (e.offsets.popper [m] - = s [ m] - (d [c] -u)), d [m] + u> s [c] && (e.offsets.popper [m] + = d [m] + us [c]), e.offsets .popper = g (e.offsets.popper); var b = d [m] + d [l] / 2-u / 2, w = t (e.instance.popper), y = parseFloat (w ['margin '+ f], 10), E = parseFloat (w [' borda '+ f +' Largura '], 10), v = be.offsets.popper [m] -yE; return v = ee (Q (s [l ] -u, v), 0), e.arrowElement = i, e.offsets.arrow = (n = {}, ae (n, m, $ (v)), ae (n, h, ''), n), e}, elemento: '[x-arrow]'}, flip: {order: 600, enabled:! 0, fn: function (e, t) {if (W (e.instance.modifiers, 'inner ')) return e; if (e.flipped && e.placement === e.originalPlacement) return e; var o = v (e.instance.popper, e.instance.reference, t.padding, t.boundariesElement, e. positionFixed), n = e.placement.split ('-') [0], i = T (n), r = e.placement.split ('-') [1] || '',p = []; switch (t.behavior) {case ce.FLIP: p = [n, i]; break; case ce.CLOCKWISE: p = G (n); break; case ce.COUNTERCLOCKWISE: p = G ( n,! 0); break; default: p = t.behavior;} return p.forEach (function (s, d) {if (n! == s || p.length === d + 1) return e ; n = e.placement.split ('-') [0], i = T (n); var a = e.offsets.popper, l = e.offsets.reference, f = Z, m = 'left' === n && f (a.right)> f (esquerda) || 'right' === n && f (a.left) <f (l.right) || 'top' === n && f (a.bottom )> f (l.top) || 'bottom' === n && f (a.top) <f (l.bottom), h = f (a.left) <f (o.left), c = f ( a.right)> f (o.right), g = f (a.top) <f (o.top), u = f (a.bottom)> f (o.bottom), b = 'esquerda' = == n && h || 'right' === n && c || 'top' === n && g || 'bottom' === n && u, w = -1! == ['top', 'bottom']. indexOf ( n), y = !! t.flipVariations && (w && 'start'=== r && h || w && 'end' === r && c ||! w && 'start' === r && g ||! w && 'end' === r && u), E = !! t.flipVariationsByContent && (w && 'start' === r && c || w && 'end' === r && h ||! w && 'start' === r && u ||! w && 'end' === r && g), v = y || E; (m || b || v) && (e.flipped =! 0, (m || b) && (n = p [d + 1]), v && (r = z (r)), e.placement = n + (r? ' - '+ r:' '), e.offsets.popper = le ({}, e.offsets.popper, C (e.instance.popper, e.offsets.reference, e.placement)), e = P ( e.instance.modifiers, e, 'flip'))}), e}, comportamento: 'flip', padding: 5, boundariesElement: 'viewport', flipVariations:! 1, flipVariationsByContent:! 1}, inner: {order : 700, ativado:! 1, fn: function (e) {var t = e.placement, o = t.split ('-') [0], n = e.offsets, i = n.popper, r = n.referência, p = -1! == ['esquerda', 'direita']. indexOf (o), s = -1 === ['superior', 'esquerda']. indexOf (o); return i [p ? 'left': 'top'] = r [o] - (s? i [p? 'width': 'height']: 0), e.placement = T (t), e.offsets.popper = g (i), e}}, ocultar: {order: 800, ativado:! 0, fn: function (e) {if (! K (e.instância.modificadores, 'ocultar', 'preventOverflow')) return e; var t = e.offsets.reference, o = D (e.instance.modifiers, function (e) {return'preventOverflow '=== e.name}). limites; if (t.bottom <o.top || t.left> o.right || t.top> o.bottom || t.right <o.left) {if (! 0 === e.hide) retorna e; e.hide =! 0, e. atributos ['x-fora-dos-limites'] = ''} else {if (! 1 === e.hide) retornam e; e.hide =! 1, e.attributes ['x-out-of- limites '] =! 1} retorne e}}, computeStyle: {order: 850, enabled:! 0, fn: function (e, t) {var o = tx, n = ty, i = e.offsets.popper, r = D (e.instância.modificadores,function (e) {return'applyStyle '=== e.name}). gpuAcceleration; void 0! == r && console.warn (' AVISO: opção `gpuAcceleration` movida para o modificador` computeStyle` e não será suportada em versões futuras É o caso de Popper.js! '); var s, d, a = void 0 === r? t.gpuAcceleration: r, l = p (e.instance.popper), f = u (l), m = {position : i.position}, h = q (e, 2> window.devicePixelRatio ||! fe), c = 'bottom' === o? 'top': 'bottom', g = 'right' === n ? 'left': 'right', b = B ('transform'); if (d = 'bottom' == c? 'HTML' === l.nodeName? -l.clientHeight + h.bottom: -f .height + h.bottom: h.top, s = 'right' == g? 'HTML' === l.nodeName? -l.clientWidth + h.right: -f.width + h.right: h. à esquerda, a && b) m [b] = 'translate3d (' + s + 'px,' + d + 'px, 0)', m [c] = 0, m [g] = 0, m.willChange = 'transform'; mais {var w = 'bottom'== c? -1: 1, y = 'direita' == g? -1: 1; m [c] = d * w, m [g] = s * y, m.willChange = c + ',' + g} var E = {"x-placement": e.placement}; retorna e.attributes = le ({}, E, e.attributes), e.styles = le ({}, m, e.styles), e.arrowStyles = le ({}, e.offsets.arrow, e.arrowStyles), e}, gpuAcceleration:! 0, x: 'bottom', y: 'right'}, applyStyle: {order: 900, enabled: ! 0, fn: function (e) {retorna V (e.instance.popper, e.styles), j (e.instance.popper, e.attributes), e.arrowElement && Object.keys (e.arrowStyles) .length && V ( e.arrowElement, e.arrowStyles), e}, onLoad: function (e, t, o, n, i) {var r = L (i, t, e, o.positionFixed), p = O (posicionamento) , r, t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip.padding); retorna t.setAttribute ('posicionamento x', p), V (t, {position: o.positionFixed? ' fixo ':' absoluto '}), o}, gpuAcceleration: void 0}}}, ge});m [g] = s * y, m.willChange = c + ',' + g} var E = {"colocação x": e.placement}; retorno e.attributes = le ({}, E, e.attributes ), e.styles = le ({}, m, e.styles), e.arrowStyles = le ({}, e.offsets.arrow, e.arrowStyles), e}, gpuAcceleration:! 0, x: 'bottom ', y:' right '}, applyStyle: {order: 900, enabled:! 0, fn: function (e) {retorna V (e.instance.popper, e.styles), j (e.instance.popper, atributos.a), e.arrowElement && Object.keys (e.arrowStyles) .length && V (e.arrowElement, e.arrowStyles), e}, onLoad: function (e, t, o, n, i) {var r = L ( i, t, e, o.positionFixed), p = O (posicionamento, r, t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip.padding); return t.setAttribute ('x- posicionamento ', p), V (t, {posição: o.positionFixed?' fixo ':' absoluto '}), o}, gpuAcceleration: void 0}}}, ge});m [g] = s * y, m.willChange = c + ',' + g} var E = {"colocação x": e.placement}; retorno e.attributes = le ({}, E, e.attributes ), e.styles = le ({}, m, e.styles), e.arrowStyles = le ({}, e.offsets.arrow, e.arrowStyles), e}, gpuAcceleration:! 0, x: 'bottom ', y:' right '}, applyStyle: {order: 900, enabled:! 0, fn: function (e) {retorna V (e.instance.popper, e.styles), j (e.instance.popper, atributos.a), e.arrowElement && Object.keys (e.arrowStyles) .length && V (e.arrowElement, e.arrowStyles), e}, onLoad: function (e, t, o, n, i) {var r = L ( i, t, e, o.positionFixed), p = O (posicionamento, r, t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip.padding); return t.setAttribute ('x- posicionamento ', p), V (t, {posição: o.positionFixed?' fixo ':' absoluto '}), o}, gpuAcceleration: void 0}}}, ge});atributos = le ({}, E, atributos e), e.styles = le ({}, m, e.styles), e.arrowStyles = le ({}, e.offsets.arrow, e.arrowStyles), e}, gpuAcceleration:! 0, x: 'bottom', y: 'right'}, applyStyle: {order: 900, enabled:! 0, fn: function (e) {retorna V (e.instance.popper, e .styles), j (e.instance.popper, e.tributes), e.arrowElement e& Object.keys (e.arrowStyles). length && V (e.arrowElement, e.arrowStyles), e}, onLoad: function (e, t, o, n, i) {var r = L (i, t, e, o.positionFixed), p = O (o.placement, r, t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip .padding); return t.setAttribute ('x-placement', p), V (t, {position: o.positionFixed? 'fixed': 'absolute'}), o}, gpuAcceleration: void 0}}}, ge});atributos = le ({}, E, atributos e), e.styles = le ({}, m, e.styles), e.arrowStyles = le ({}, e.offsets.arrow, e.arrowStyles), e}, gpuAcceleration:! 0, x: 'bottom', y: 'right'}, applyStyle: {order: 900, enabled:! 0, fn: function (e) {retorna V (e.instance.popper, e .styles), j (e.instance.popper, e.tributes), e.arrowElement e& Object.keys (e.arrowStyles). length && V (e.arrowElement, e.arrowStyles), e}, onLoad: function (e, t, o, n, i) {var r = L (i, t, e, o.positionFixed), p = O (o.placement, r, t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip .padding); return t.setAttribute ('x-placement', p), V (t, {position: o.positionFixed? 'fixed': 'absolute'}), o}, gpuAcceleration: void 0}}}, ge});applyStyle: {order: 900, enabled:! 0, fn: function (e) {retorna V (e.instance.popper, e.styles), j (e.instance.popper, e.attributes), e.arrowElement && Object. chaves (e.arrowStyles) .length && V (e.arrowElement, e.arrowStyles), e}, onLoad: function (e, t, o, n, i) {var r = L (i, t, e, o.positionFixed ), p = O (o.placement, r, t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip.padding); return t.setAttribute ('colocação x', p), V (t , {position: o.positionFixed? 'fixed': 'absolute'}), o}, gpuAcceleration: void 0}}}, ge});applyStyle: {order: 900, enabled:! 0, fn: function (e) {retorna V (e.instance.popper, e.styles), j (e.instance.popper, e.attributes), e.arrowElement && Object. chaves (e.arrowStyles) .length && V (e.arrowElement, e.arrowStyles), e}, onLoad: function (e, t, o, n, i) {var r = L (i, t, e, o.positionFixed ), p = O (o.placement, r, t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip.padding); return t.setAttribute ('colocação x', p), V (t , {position: o.positionFixed? 'fixed': 'absolute'}), o}, gpuAcceleration: void 0}}}, ge});padding); return t.setAttribute ('x-placement', p), V (t, {position: o.positionFixed? 'fixed': 'absolute'}), o}, gpuAcceleration: void 0}}}, ge });padding); return t.setAttribute ('x-placement', p), V (t, {position: o.positionFixed? 'fixed': 'absolute'}), o}, gpuAcceleration: void 0}}}, ge });
// # sourceMappingURL = popper.min.js.map